
recieve_main_skel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00000582  00000616  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000582  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  0080010a  0080010a  00000620  2**0
                  ALLOC
  3 .stab         00001f98  00000000  00000000  00000620  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000113f  00000000  00000000  000025b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000036f7  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	11 e0       	ldi	r17, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	e2 e8       	ldi	r30, 0x82	; 130
  c0:	f5 e0       	ldi	r31, 0x05	; 5
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	aa 30       	cpi	r26, 0x0A	; 10
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	11 e0       	ldi	r17, 0x01	; 1
  d0:	aa e0       	ldi	r26, 0x0A	; 10
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a1 31       	cpi	r26, 0x11	; 17
  da:	b1 07       	cpc	r27, r17
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 9c 02 	call	0x538	; 0x538 <main>
  e2:	0c 94 bf 02 	jmp	0x57e	; 0x57e <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <light_routine>:
/* ------------------------------------------------------------------------- */
void light_routine(void){
 uint8_t l = 5;
 uint16_t i, ii; 
 //Init PORTD to turn on lights
 DDRD |= (1<<PD7)|(1<<PD6)|(1<<PD5); //set light pins to output
  ea:	8a b1       	in	r24, 0x0a	; 10
  ec:	80 6e       	ori	r24, 0xE0	; 224
  ee:	8a b9       	out	0x0a, r24	; 10
  f0:	26 e0       	ldi	r18, 0x06	; 6
  f2:	30 e0       	ldi	r19, 0x00	; 0
uint8_t data_array[4];
uint8_t tx_address[5] = {0xD7,0xD7,0xD7,0xD7,0xD7};
uint8_t rx_address[5] = {0xE7,0xE7,0xE7,0xE7,0xE7};
/* ------------------------------------------------------------------------- */
void light_routine(void){
 uint8_t l = 5;
  f4:	65 e0       	ldi	r22, 0x05	; 5
  f6:	71 e0       	ldi	r23, 0x01	; 1
 uint16_t i, ii; 
 //Init PORTD to turn on lights
 DDRD |= (1<<PD7)|(1<<PD6)|(1<<PD5); //set light pins to output
//while(1){//spin forever
 for(ii=0; ii<6; ii++){
  l++; 
  f8:	6f 5f       	subi	r22, 0xFF	; 255
  fa:	57 2f       	mov	r21, r23
  fc:	06 2e       	mov	r0, r22
  fe:	01 c0       	rjmp	.+2      	; 0x102 <light_routine+0x18>
 100:	55 0f       	add	r21, r21
 102:	0a 94       	dec	r0
 104:	ea f7       	brpl	.-6      	; 0x100 <light_routine+0x16>
 106:	8a ef       	ldi	r24, 0xFA	; 250
 108:	90 e0       	ldi	r25, 0x00	; 0
  for(i=0;i<250; i++){
   PORTD |= (1<<l);
 10a:	4b b1       	in	r20, 0x0b	; 11
 10c:	45 2b       	or	r20, r21
 10e:	4b b9       	out	0x0b, r20	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 110:	e3 ef       	ldi	r30, 0xF3	; 243
 112:	f1 e0       	ldi	r31, 0x01	; 1
 114:	31 97       	sbiw	r30, 0x01	; 1
 116:	f1 f7       	brne	.-4      	; 0x114 <light_routine+0x2a>
 118:	00 c0       	rjmp	.+0      	; 0x11a <light_routine+0x30>
 11a:	00 00       	nop
   _delay_ms(2);
   PORTD = 0;
 11c:	1b b8       	out	0x0b, r1	; 11
 11e:	01 97       	sbiw	r24, 0x01	; 1
 //Init PORTD to turn on lights
 DDRD |= (1<<PD7)|(1<<PD6)|(1<<PD5); //set light pins to output
//while(1){//spin forever
 for(ii=0; ii<6; ii++){
  l++; 
  for(i=0;i<250; i++){
 120:	00 97       	sbiw	r24, 0x00	; 0
 122:	99 f7       	brne	.-26     	; 0x10a <light_routine+0x20>
   PORTD |= (1<<l);
   _delay_ms(2);
   PORTD = 0;
  }
  if(l>6){l = 4;};
 124:	67 30       	cpi	r22, 0x07	; 7
 126:	09 f4       	brne	.+2      	; 0x12a <light_routine+0x40>
 128:	64 e0       	ldi	r22, 0x04	; 4
 12a:	21 50       	subi	r18, 0x01	; 1
 12c:	31 09       	sbc	r19, r1
 uint8_t l = 5;
 uint16_t i, ii; 
 //Init PORTD to turn on lights
 DDRD |= (1<<PD7)|(1<<PD6)|(1<<PD5); //set light pins to output
//while(1){//spin forever
 for(ii=0; ii<6; ii++){
 12e:	21 15       	cp	r18, r1
 130:	31 05       	cpc	r19, r1
 132:	11 f7       	brne	.-60     	; 0xf8 <light_routine+0xe>
   _delay_ms(2);
   PORTD = 0;
  }
  if(l>6){l = 4;};
 }//for
}//light routine
 134:	08 95       	ret

00000136 <nrf24_ce_digitalWrite.part.0>:
 *    - state:0 => Pin LOW     */
void nrf24_ce_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,0);
 136:	28 9a       	sbi	0x05, 0	; 5
 138:	08 95       	ret

0000013a <nrf24_csn_digitalWrite.part.1>:
}
void nrf24_csn_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,4);
 13a:	2c 9a       	sbi	0x05, 4	; 5
 13c:	08 95       	ret

0000013e <nrf24_payload_length>:

/* Returns the payload length */
uint8_t nrf24_payload_length()
{
    return payload_len;
}
 13e:	80 91 10 01 	lds	r24, 0x0110
 142:	08 95       	ret

00000144 <spi_transfer>:
    {
        set_bit(PORTB,7);
    }
    else
    {
        clr_bit(PORTB,7);
 144:	2f 98       	cbi	0x05, 7	; 5
 146:	68 2f       	mov	r22, r24
 148:	70 e0       	ldi	r23, 0x00	; 0
 14a:	27 e0       	ldi	r18, 0x07	; 7
 14c:	30 e0       	ldi	r19, 0x00	; 0

/* software spi routine */
uint8_t spi_transfer(uint8_t tx)
{
    uint8_t i = 0;
    uint8_t rx = 0;    
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	09 c0       	rjmp	.+18     	; 0x164 <spi_transfer+0x20>
    {
        set_bit(PORTB,5);
    }
    else
    {
        clr_bit(PORTB,5);
 152:	2d 98       	cbi	0x05, 5	; 5
}
void nrf24_sck_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,7);
 154:	2f 9a       	sbi	0x05, 7	; 5
            nrf24_mosi_digitalWrite(LOW);
        }

        nrf24_sck_digitalWrite(HIGH);        

        rx = rx << 1;
 156:	88 0f       	add	r24, r24
        if(nrf24_miso_digitalRead())
 158:	1e 99       	sbic	0x03, 6	; 3
        {
            rx |= 0x01;
 15a:	81 60       	ori	r24, 0x01	; 1
    {
        set_bit(PORTB,7);
    }
    else
    {
        clr_bit(PORTB,7);
 15c:	2f 98       	cbi	0x05, 7	; 5
 15e:	21 50       	subi	r18, 0x01	; 1
 160:	31 09       	sbc	r19, r1
 162:	58 f0       	brcs	.+22     	; 0x17a <spi_transfer+0x36>
    nrf24_sck_digitalWrite(LOW);

    for(i=0;i<8;i++)
    {

        if(tx & (1<<(7-i)))
 164:	ab 01       	movw	r20, r22
 166:	02 2e       	mov	r0, r18
 168:	02 c0       	rjmp	.+4      	; 0x16e <spi_transfer+0x2a>
 16a:	55 95       	asr	r21
 16c:	47 95       	ror	r20
 16e:	0a 94       	dec	r0
 170:	e2 f7       	brpl	.-8      	; 0x16a <spi_transfer+0x26>
 172:	40 ff       	sbrs	r20, 0
 174:	ee cf       	rjmp	.-36     	; 0x152 <spi_transfer+0xe>
}
void nrf24_mosi_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,5);
 176:	2d 9a       	sbi	0x05, 5	; 5
 178:	ed cf       	rjmp	.-38     	; 0x154 <spi_transfer+0x10>
        nrf24_sck_digitalWrite(LOW);                

    }

    return rx;
}
 17a:	08 95       	ret

0000017c <nrf24_payloadLength>:
    return (fifoStatus & (1 << RX_EMPTY));
}

/* Returns the length of data waiting in the RX fifo */
uint8_t nrf24_payloadLength()
{
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	1f 92       	push	r1
 182:	cd b7       	in	r28, 0x3d	; 61
 184:	de b7       	in	r29, 0x3e	; 62
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 186:	2c 98       	cbi	0x05, 4	; 5
/* Returns the length of data waiting in the RX fifo */
uint8_t nrf24_payloadLength()
{
    uint8_t status;
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(R_RX_PL_WID);
 188:	80 e6       	ldi	r24, 0x60	; 96
 18a:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
    status = spi_transfer(0x00);
 18e:	80 e0       	ldi	r24, 0x00	; 0
 190:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 194:	89 83       	std	Y+1, r24	; 0x01
 196:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    nrf24_csn_digitalWrite(HIGH);
    return status;
}
 19a:	89 81       	ldd	r24, Y+1	; 0x01
 19c:	0f 90       	pop	r0
 19e:	df 91       	pop	r29
 1a0:	cf 91       	pop	r28
 1a2:	08 95       	ret

000001a4 <nrf24_getStatus>:
    return 1; /* true */

}

uint8_t nrf24_getStatus()
{
 1a4:	cf 93       	push	r28
 1a6:	df 93       	push	r29
 1a8:	1f 92       	push	r1
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 1ae:	2c 98       	cbi	0x05, 4	; 5

uint8_t nrf24_getStatus()
{
    uint8_t rv;
    nrf24_csn_digitalWrite(LOW);
    rv = spi_transfer(NOP);
 1b0:	8f ef       	ldi	r24, 0xFF	; 255
 1b2:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 1b6:	89 83       	std	Y+1, r24	; 0x01
 1b8:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    nrf24_csn_digitalWrite(HIGH);
    return rv;
}
 1bc:	89 81       	ldd	r24, Y+1	; 0x01
 1be:	0f 90       	pop	r0
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	08 95       	ret

000001c6 <nrf24_isSending>:
uint8_t nrf24_isSending()
{
    uint8_t status;

    /* read the current status */
    status = nrf24_getStatus();
 1c6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <nrf24_getStatus>
                
    /* if sending successful (TX_DS) or max retries exceded (MAX_RT). */
    if((status & ((1 << TX_DS)  | (1 << MAX_RT))))
 1ca:	98 2f       	mov	r25, r24
 1cc:	90 73       	andi	r25, 0x30	; 48
 1ce:	81 e0       	ldi	r24, 0x01	; 1
 1d0:	09 f0       	breq	.+2      	; 0x1d4 <nrf24_isSending+0xe>
 1d2:	80 e0       	ldi	r24, 0x00	; 0
        return 0; /* false */
    }

    return 1; /* true */

}
 1d4:	08 95       	ret

000001d6 <nrf24_lastMessageStatus>:

uint8_t nrf24_lastMessageStatus()
{
    uint8_t rv;

    rv = nrf24_getStatus();
 1d6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <nrf24_getStatus>

    /* Transmission went OK */
    if((rv & ((1 << TX_DS))))
 1da:	85 fd       	sbrc	r24, 5
 1dc:	06 c0       	rjmp	.+12     	; 0x1ea <nrf24_lastMessageStatus+0x14>
    {
        return NRF24_TRANSMISSON_OK;
    }
    /* Maximum retransmission count is reached */
    /* Last message probably went missing ... */
    else if((rv & ((1 << MAX_RT))))
 1de:	84 fd       	sbrc	r24, 4
 1e0:	02 c0       	rjmp	.+4      	; 0x1e6 <nrf24_lastMessageStatus+0x10>
        return NRF24_MESSAGE_LOST;
    }  
    /* Probably still sending ... */
    else
    {
        return 0xFF;
 1e2:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
 1e4:	08 95       	ret
    }
    /* Maximum retransmission count is reached */
    /* Last message probably went missing ... */
    else if((rv & ((1 << MAX_RT))))
    {
        return NRF24_MESSAGE_LOST;
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	08 95       	ret
    rv = nrf24_getStatus();

    /* Transmission went OK */
    if((rv & ((1 << TX_DS))))
    {
        return NRF24_TRANSMISSON_OK;
 1ea:	80 e0       	ldi	r24, 0x00	; 0
 1ec:	08 95       	ret

000001ee <nrf24_transferSync>:
    return rx;
}

/* send and receive multiple bytes over SPI */
void nrf24_transferSync(uint8_t* dataout,uint8_t* datain,uint8_t len)
{
 1ee:	ef 92       	push	r14
 1f0:	ff 92       	push	r15
 1f2:	0f 93       	push	r16
 1f4:	1f 93       	push	r17
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	e4 2e       	mov	r14, r20
    uint8_t i;

    for(i=0;i<len;i++)
 1fc:	44 23       	and	r20, r20
 1fe:	61 f0       	breq	.+24     	; 0x218 <nrf24_transferSync+0x2a>
 200:	8c 01       	movw	r16, r24
 202:	eb 01       	movw	r28, r22
 204:	f1 2c       	mov	r15, r1
    {
        datain[i] = spi_transfer(dataout[i]);
 206:	f8 01       	movw	r30, r16
 208:	81 91       	ld	r24, Z+
 20a:	8f 01       	movw	r16, r30
 20c:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 210:	89 93       	st	Y+, r24
/* send and receive multiple bytes over SPI */
void nrf24_transferSync(uint8_t* dataout,uint8_t* datain,uint8_t len)
{
    uint8_t i;

    for(i=0;i<len;i++)
 212:	f3 94       	inc	r15
 214:	fe 10       	cpse	r15, r14
 216:	f7 cf       	rjmp	.-18     	; 0x206 <nrf24_transferSync+0x18>
    {
        datain[i] = spi_transfer(dataout[i]);
    }

}
 218:	df 91       	pop	r29
 21a:	cf 91       	pop	r28
 21c:	1f 91       	pop	r17
 21e:	0f 91       	pop	r16
 220:	ff 90       	pop	r15
 222:	ef 90       	pop	r14
 224:	08 95       	ret

00000226 <nrf24_transmitSync>:

/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
 226:	0f 93       	push	r16
 228:	1f 93       	push	r17
 22a:	cf 93       	push	r28
 22c:	df 93       	push	r29
 22e:	06 2f       	mov	r16, r22
    uint8_t i;
    
    for(i=0;i<len;i++)
 230:	66 23       	and	r22, r22
 232:	41 f0       	breq	.+16     	; 0x244 <nrf24_transmitSync+0x1e>
 234:	ec 01       	movw	r28, r24
 236:	10 e0       	ldi	r17, 0x00	; 0
    {
        spi_transfer(dataout[i]);
 238:	89 91       	ld	r24, Y+
 23a:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
    uint8_t i;
    
    for(i=0;i<len;i++)
 23e:	1f 5f       	subi	r17, 0xFF	; 255
 240:	10 13       	cpse	r17, r16
 242:	fa cf       	rjmp	.-12     	; 0x238 <nrf24_transmitSync+0x12>
    {
        spi_transfer(dataout[i]);
    }

}
 244:	df 91       	pop	r29
 246:	cf 91       	pop	r28
 248:	1f 91       	pop	r17
 24a:	0f 91       	pop	r16
 24c:	08 95       	ret

0000024e <nrf24_configRegister>:

/* Clocks only one byte into the given nrf24 register */
void nrf24_configRegister(uint8_t reg, uint8_t value)
{
 24e:	cf 93       	push	r28
 250:	df 93       	push	r29
 252:	1f 92       	push	r1
 254:	cd b7       	in	r28, 0x3d	; 61
 256:	de b7       	in	r29, 0x3e	; 62
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 258:	2c 98       	cbi	0x05, 4	; 5

/* Clocks only one byte into the given nrf24 register */
void nrf24_configRegister(uint8_t reg, uint8_t value)
{
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(W_REGISTER | (REGISTER_MASK & reg));
 25a:	8f 71       	andi	r24, 0x1F	; 31
 25c:	80 62       	ori	r24, 0x20	; 32
 25e:	69 83       	std	Y+1, r22	; 0x01
 260:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
    spi_transfer(value);
 264:	69 81       	ldd	r22, Y+1	; 0x01
 266:	86 2f       	mov	r24, r22
 268:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
    nrf24_csn_digitalWrite(HIGH);
}
 26c:	0f 90       	pop	r0
 26e:	df 91       	pop	r29
 270:	cf 91       	pop	r28
 272:	0c 94 9d 00 	jmp	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>

00000276 <nrf24_getData>:
    return status;
}

/* Reads payload bytes into data array */
void nrf24_getData(uint8_t* data) 
{
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
 27a:	ec 01       	movw	r28, r24
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 27c:	2c 98       	cbi	0x05, 4	; 5
{
    /* Pull down chip select */
    nrf24_csn_digitalWrite(LOW);                               

    /* Send cmd to read rx payload */
    spi_transfer( R_RX_PAYLOAD );
 27e:	81 e6       	ldi	r24, 0x61	; 97
 280:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
    
    /* Read payload */
    nrf24_transferSync(data,data,payload_len);
 284:	40 91 10 01 	lds	r20, 0x0110
 288:	be 01       	movw	r22, r28
 28a:	ce 01       	movw	r24, r28
 28c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <nrf24_transferSync>
 290:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    
    /* Pull up chip select */
    nrf24_csn_digitalWrite(HIGH);

    /* Reset status register */
    nrf24_configRegister(STATUS,(1<<RX_DR));   
 294:	60 e4       	ldi	r22, 0x40	; 64
 296:	87 e0       	ldi	r24, 0x07	; 7
}
 298:	df 91       	pop	r29
 29a:	cf 91       	pop	r28
    
    /* Pull up chip select */
    nrf24_csn_digitalWrite(HIGH);

    /* Reset status register */
    nrf24_configRegister(STATUS,(1<<RX_DR));   
 29c:	0c 94 27 01 	jmp	0x24e	; 0x24e <nrf24_configRegister>

000002a0 <nrf24_powerUpRx>:
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 2a0:	2c 98       	cbi	0x05, 4	; 5
}

void nrf24_powerUpRx()
{     
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(FLUSH_RX);
 2a2:	82 ee       	ldi	r24, 0xE2	; 226
 2a4:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 2a8:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    nrf24_csn_digitalWrite(HIGH);

    nrf24_configRegister(STATUS,(1<<RX_DR)|(1<<TX_DS)|(1<<MAX_RT)); 
 2ac:	60 e7       	ldi	r22, 0x70	; 112
 2ae:	87 e0       	ldi	r24, 0x07	; 7
 2b0:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 2b4:	28 98       	cbi	0x05, 0	; 5
    nrf24_csn_digitalWrite(HIGH);

    nrf24_configRegister(STATUS,(1<<RX_DR)|(1<<TX_DS)|(1<<MAX_RT)); 

    nrf24_ce_digitalWrite(LOW);    
    nrf24_configRegister(CONFIG,nrf24_CONFIG|((1<<PWR_UP)|(1<<PRIM_RX)));    
 2b6:	6b e0       	ldi	r22, 0x0B	; 11
 2b8:	80 e0       	ldi	r24, 0x00	; 0
 2ba:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
 2be:	0c 94 9b 00 	jmp	0x136	; 0x136 <nrf24_ce_digitalWrite.part.0>

000002c2 <nrf24_config>:

/* configure the module */
void nrf24_config(uint8_t channel, uint8_t pay_length)
{
    /* Use static payload length ... */
    payload_len = pay_length;
 2c2:	60 93 10 01 	sts	0x0110, r22

    // Set RF channel
    nrf24_configRegister(RF_CH,channel);
 2c6:	68 2f       	mov	r22, r24
 2c8:	85 e0       	ldi	r24, 0x05	; 5
 2ca:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Set length of incoming payload 
    nrf24_configRegister(RX_PW_P0, 0x00); // Auto-ACK pipe ...
 2ce:	60 e0       	ldi	r22, 0x00	; 0
 2d0:	81 e1       	ldi	r24, 0x11	; 17
 2d2:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    nrf24_configRegister(RX_PW_P1, payload_len); // Data payload pipe
 2d6:	60 91 10 01 	lds	r22, 0x0110
 2da:	82 e1       	ldi	r24, 0x12	; 18
 2dc:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    nrf24_configRegister(RX_PW_P2, 0x00); // Pipe not used 
 2e0:	60 e0       	ldi	r22, 0x00	; 0
 2e2:	83 e1       	ldi	r24, 0x13	; 19
 2e4:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    nrf24_configRegister(RX_PW_P3, 0x00); // Pipe not used 
 2e8:	60 e0       	ldi	r22, 0x00	; 0
 2ea:	84 e1       	ldi	r24, 0x14	; 20
 2ec:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    nrf24_configRegister(RX_PW_P4, 0x00); // Pipe not used 
 2f0:	60 e0       	ldi	r22, 0x00	; 0
 2f2:	85 e1       	ldi	r24, 0x15	; 21
 2f4:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>
    nrf24_configRegister(RX_PW_P5, 0x00); // Pipe not used 
 2f8:	60 e0       	ldi	r22, 0x00	; 0
 2fa:	86 e1       	ldi	r24, 0x16	; 22
 2fc:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // 1 Mbps, TX gain: 0dbm
    nrf24_configRegister(RF_SETUP, (0<<RF_DR)|((0x03)<<RF_PWR));
 300:	66 e0       	ldi	r22, 0x06	; 6
 302:	86 e0       	ldi	r24, 0x06	; 6
 304:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // CRC enable, 1 byte CRC length
    nrf24_configRegister(CONFIG,nrf24_CONFIG);
 308:	68 e0       	ldi	r22, 0x08	; 8
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Auto Acknowledgment
    nrf24_configRegister(EN_AA,(1<<ENAA_P0)|(1<<ENAA_P1)|(0<<ENAA_P2)|(0<<ENAA_P3)|(0<<ENAA_P4)|(0<<ENAA_P5));
 310:	63 e0       	ldi	r22, 0x03	; 3
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Enable RX addresses
    nrf24_configRegister(EN_RXADDR,(1<<ERX_P0)|(1<<ERX_P1)|(0<<ERX_P2)|(0<<ERX_P3)|(0<<ERX_P4)|(0<<ERX_P5));
 318:	63 e0       	ldi	r22, 0x03	; 3
 31a:	82 e0       	ldi	r24, 0x02	; 2
 31c:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Auto retransmit delay: 1000 us and Up to 15 retransmit trials
    nrf24_configRegister(SETUP_RETR,(0x04<<ARD)|(0x0F<<ARC));
 320:	6f e4       	ldi	r22, 0x4F	; 79
 322:	84 e0       	ldi	r24, 0x04	; 4
 324:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Dynamic length configurations: No dynamic length
    nrf24_configRegister(DYNPD,(0<<DPL_P0)|(0<<DPL_P1)|(0<<DPL_P2)|(0<<DPL_P3)|(0<<DPL_P4)|(0<<DPL_P5));
 328:	60 e0       	ldi	r22, 0x00	; 0
 32a:	8c e1       	ldi	r24, 0x1C	; 28
 32c:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    // Start listening
    nrf24_powerUpRx();
 330:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <nrf24_powerUpRx>

00000334 <nrf24_powerUpTx>:
    nrf24_ce_digitalWrite(HIGH);
}

void nrf24_powerUpTx()
{
    nrf24_configRegister(STATUS,(1<<RX_DR)|(1<<TX_DS)|(1<<MAX_RT)); 
 334:	60 e7       	ldi	r22, 0x70	; 112
 336:	87 e0       	ldi	r24, 0x07	; 7
 338:	0e 94 27 01 	call	0x24e	; 0x24e <nrf24_configRegister>

    nrf24_configRegister(CONFIG,nrf24_CONFIG|((1<<PWR_UP)|(0<<PRIM_RX)));
 33c:	6a e0       	ldi	r22, 0x0A	; 10
 33e:	80 e0       	ldi	r24, 0x00	; 0
 340:	0c 94 27 01 	jmp	0x24e	; 0x24e <nrf24_configRegister>

00000344 <nrf24_send>:
}

// Sends a data package to the default address. Be sure to send the correct
// amount of bytes as configured as payload on the receiver.
void nrf24_send(uint8_t* value) 
{    
 344:	cf 92       	push	r12
 346:	df 92       	push	r13
 348:	ff 92       	push	r15
 34a:	0f 93       	push	r16
 34c:	1f 93       	push	r17
 34e:	cf 93       	push	r28
 350:	df 93       	push	r29
 352:	1f 92       	push	r1
 354:	cd b7       	in	r28, 0x3d	; 61
 356:	de b7       	in	r29, 0x3e	; 62
 358:	f8 2e       	mov	r15, r24
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 35a:	28 98       	cbi	0x05, 0	; 5
{    
    /* Go to Standby-I first */
    nrf24_ce_digitalWrite(LOW);
     
    /* Set to transmitter mode , Power up if needed */
    nrf24_powerUpTx();
 35c:	99 83       	std	Y+1, r25	; 0x01
 35e:	0e 94 9a 01 	call	0x334	; 0x334 <nrf24_powerUpTx>
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 362:	2c 98       	cbi	0x05, 4	; 5
    #if 1
        /* Pull down chip select */
        nrf24_csn_digitalWrite(LOW);           

        /* Write cmd to flush transmit FIFO */
        spi_transfer(FLUSH_TX);     
 364:	81 ee       	ldi	r24, 0xE1	; 225
 366:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 36a:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 36e:	2c 98       	cbi	0x05, 4	; 5

    /* Pull down chip select */
    nrf24_csn_digitalWrite(LOW);

    /* Write cmd to write payload */
    spi_transfer(W_TX_PAYLOAD);
 370:	80 ea       	ldi	r24, 0xA0	; 160
 372:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>

    /* Write payload */
    nrf24_transmitSync(value,payload_len);   
 376:	10 91 10 01 	lds	r17, 0x0110
/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
    uint8_t i;
    
    for(i=0;i<len;i++)
 37a:	99 81       	ldd	r25, Y+1	; 0x01
 37c:	11 23       	and	r17, r17
 37e:	61 f0       	breq	.+24     	; 0x398 <nrf24_send+0x54>
 380:	0f 2d       	mov	r16, r15
 382:	cf 2c       	mov	r12, r15
 384:	d9 2e       	mov	r13, r25
    {
        spi_transfer(dataout[i]);
 386:	f6 01       	movw	r30, r12
 388:	81 91       	ld	r24, Z+
 38a:	6f 01       	movw	r12, r30
 38c:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
 390:	8c 2d       	mov	r24, r12
 392:	80 1b       	sub	r24, r16
/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
    uint8_t i;
    
    for(i=0;i<len;i++)
 394:	81 17       	cp	r24, r17
 396:	b8 f3       	brcs	.-18     	; 0x386 <nrf24_send+0x42>
 398:	0e 94 9d 00 	call	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>
    /* Pull up chip select */
    nrf24_csn_digitalWrite(HIGH);

    /* Start the transmission */
    nrf24_ce_digitalWrite(HIGH);    
}
 39c:	0f 90       	pop	r0
 39e:	df 91       	pop	r29
 3a0:	cf 91       	pop	r28
 3a2:	1f 91       	pop	r17
 3a4:	0f 91       	pop	r16
 3a6:	ff 90       	pop	r15
 3a8:	df 90       	pop	r13
 3aa:	cf 90       	pop	r12
 3ac:	0c 94 9b 00 	jmp	0x136	; 0x136 <nrf24_ce_digitalWrite.part.0>

000003b0 <nrf24_powerDown>:
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 3b0:	28 98       	cbi	0x05, 0	; 5
}

void nrf24_powerDown()
{
    nrf24_ce_digitalWrite(LOW);
    nrf24_configRegister(CONFIG,nrf24_CONFIG);
 3b2:	68 e0       	ldi	r22, 0x08	; 8
 3b4:	80 e0       	ldi	r24, 0x00	; 0
 3b6:	0c 94 27 01 	jmp	0x24e	; 0x24e <nrf24_configRegister>

000003ba <nrf24_readRegister>:
    nrf24_csn_digitalWrite(HIGH);
}

/* Read single register from nrf24 */
void nrf24_readRegister(uint8_t reg, uint8_t* value, uint8_t len)
{
 3ba:	0f 93       	push	r16
 3bc:	1f 93       	push	r17
 3be:	cf 93       	push	r28
 3c0:	df 93       	push	r29
 3c2:	1f 92       	push	r1
 3c4:	cd b7       	in	r28, 0x3d	; 61
 3c6:	de b7       	in	r29, 0x3e	; 62
 3c8:	8b 01       	movw	r16, r22
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 3ca:	2c 98       	cbi	0x05, 4	; 5

/* Read single register from nrf24 */
void nrf24_readRegister(uint8_t reg, uint8_t* value, uint8_t len)
{
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(R_REGISTER | (REGISTER_MASK & reg));
 3cc:	8f 71       	andi	r24, 0x1F	; 31
 3ce:	49 83       	std	Y+1, r20	; 0x01
 3d0:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
    nrf24_transferSync(value,value,len);
 3d4:	49 81       	ldd	r20, Y+1	; 0x01
 3d6:	b8 01       	movw	r22, r16
 3d8:	c8 01       	movw	r24, r16
 3da:	0e 94 f7 00 	call	0x1ee	; 0x1ee <nrf24_transferSync>
    nrf24_csn_digitalWrite(HIGH);
}
 3de:	0f 90       	pop	r0
 3e0:	df 91       	pop	r29
 3e2:	cf 91       	pop	r28
 3e4:	1f 91       	pop	r17
 3e6:	0f 91       	pop	r16
 3e8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>

000003ec <nrf24_rxFifoEmpty>:
    return !nrf24_rxFifoEmpty();;
}

/* Checks if receive FIFO is empty or not */
uint8_t nrf24_rxFifoEmpty()
{
 3ec:	cf 93       	push	r28
 3ee:	df 93       	push	r29
 3f0:	1f 92       	push	r1
 3f2:	cd b7       	in	r28, 0x3d	; 61
 3f4:	de b7       	in	r29, 0x3e	; 62
    uint8_t fifoStatus;

    nrf24_readRegister(FIFO_STATUS,&fifoStatus,1);
 3f6:	41 e0       	ldi	r20, 0x01	; 1
 3f8:	be 01       	movw	r22, r28
 3fa:	6f 5f       	subi	r22, 0xFF	; 255
 3fc:	7f 4f       	sbci	r23, 0xFF	; 255
 3fe:	87 e1       	ldi	r24, 0x17	; 23
 400:	0e 94 dd 01 	call	0x3ba	; 0x3ba <nrf24_readRegister>
    
    return (fifoStatus & (1 << RX_EMPTY));
 404:	89 81       	ldd	r24, Y+1	; 0x01
}
 406:	81 70       	andi	r24, 0x01	; 1
 408:	0f 90       	pop	r0
 40a:	df 91       	pop	r29
 40c:	cf 91       	pop	r28
 40e:	08 95       	ret

00000410 <nrf24_dataReady>:
}

/* Checks if data is available for reading */
/* Returns 1 if data is ready ... */
uint8_t nrf24_dataReady() 
{
 410:	cf 93       	push	r28
 412:	df 93       	push	r29
 414:	1f 92       	push	r1
 416:	cd b7       	in	r28, 0x3d	; 61
 418:	de b7       	in	r29, 0x3e	; 62
    // See note in getData() function - just checking RX_DR isn't good enough
    uint8_t status = nrf24_getStatus();
 41a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <nrf24_getStatus>

    // We can short circuit on RX_DR, but if it's not set, we still need
    // to check the FIFO for any pending packets
    if ( status & (1 << RX_DR) ) 
 41e:	86 ff       	sbrs	r24, 6
 420:	05 c0       	rjmp	.+10     	; 0x42c <nrf24_dataReady+0x1c>
    {
        return 1;
 422:	81 e0       	ldi	r24, 0x01	; 1
    }

    return !nrf24_rxFifoEmpty();;
}
 424:	0f 90       	pop	r0
 426:	df 91       	pop	r29
 428:	cf 91       	pop	r28
 42a:	08 95       	ret
/* Checks if receive FIFO is empty or not */
uint8_t nrf24_rxFifoEmpty()
{
    uint8_t fifoStatus;

    nrf24_readRegister(FIFO_STATUS,&fifoStatus,1);
 42c:	41 e0       	ldi	r20, 0x01	; 1
 42e:	be 01       	movw	r22, r28
 430:	6f 5f       	subi	r22, 0xFF	; 255
 432:	7f 4f       	sbci	r23, 0xFF	; 255
 434:	87 e1       	ldi	r24, 0x17	; 23
 436:	0e 94 dd 01 	call	0x3ba	; 0x3ba <nrf24_readRegister>
    
    return (fifoStatus & (1 << RX_EMPTY));
 43a:	89 81       	ldd	r24, Y+1	; 0x01
 43c:	80 95       	com	r24
 43e:	81 70       	andi	r24, 0x01	; 1
    {
        return 1;
    }

    return !nrf24_rxFifoEmpty();;
}
 440:	0f 90       	pop	r0
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	08 95       	ret

00000448 <nrf24_retransmissionCount>:
    nrf24_configRegister(STATUS,(1<<RX_DR));   
}

/* Returns the number of retransmissions occured for the last message */
uint8_t nrf24_retransmissionCount()
{
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
 44c:	1f 92       	push	r1
 44e:	cd b7       	in	r28, 0x3d	; 61
 450:	de b7       	in	r29, 0x3e	; 62
    uint8_t rv;
    nrf24_readRegister(OBSERVE_TX,&rv,1);
 452:	41 e0       	ldi	r20, 0x01	; 1
 454:	be 01       	movw	r22, r28
 456:	6f 5f       	subi	r22, 0xFF	; 255
 458:	7f 4f       	sbci	r23, 0xFF	; 255
 45a:	88 e0       	ldi	r24, 0x08	; 8
 45c:	0e 94 dd 01 	call	0x3ba	; 0x3ba <nrf24_readRegister>
    rv = rv & 0x0F;
 460:	89 81       	ldd	r24, Y+1	; 0x01
    return rv;
}
 462:	8f 70       	andi	r24, 0x0F	; 15
 464:	0f 90       	pop	r0
 466:	df 91       	pop	r29
 468:	cf 91       	pop	r28
 46a:	08 95       	ret

0000046c <nrf24_writeRegister>:
    nrf24_csn_digitalWrite(HIGH);
}

/* Write to a single register of nrf24 */
void nrf24_writeRegister(uint8_t reg, uint8_t* value, uint8_t len) 
{
 46c:	ef 92       	push	r14
 46e:	ff 92       	push	r15
 470:	0f 93       	push	r16
 472:	1f 93       	push	r17
 474:	cf 93       	push	r28
 476:	df 93       	push	r29
 478:	00 d0       	rcall	.+0      	; 0x47a <nrf24_writeRegister+0xe>
 47a:	cd b7       	in	r28, 0x3d	; 61
 47c:	de b7       	in	r29, 0x3e	; 62
 47e:	04 2f       	mov	r16, r20
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 480:	2c 98       	cbi	0x05, 4	; 5

/* Write to a single register of nrf24 */
void nrf24_writeRegister(uint8_t reg, uint8_t* value, uint8_t len) 
{
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(W_REGISTER | (REGISTER_MASK & reg));
 482:	8f 71       	andi	r24, 0x1F	; 31
 484:	80 62       	ori	r24, 0x20	; 32
 486:	69 83       	std	Y+1, r22	; 0x01
 488:	7a 83       	std	Y+2, r23	; 0x02
 48a:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
    uint8_t i;
    
    for(i=0;i<len;i++)
 48e:	69 81       	ldd	r22, Y+1	; 0x01
 490:	7a 81       	ldd	r23, Y+2	; 0x02
 492:	00 23       	and	r16, r16
 494:	51 f0       	breq	.+20     	; 0x4aa <nrf24_writeRegister+0x3e>
 496:	7b 01       	movw	r14, r22
 498:	10 e0       	ldi	r17, 0x00	; 0
    {
        spi_transfer(dataout[i]);
 49a:	f7 01       	movw	r30, r14
 49c:	81 91       	ld	r24, Z+
 49e:	7f 01       	movw	r14, r30
 4a0:	0e 94 a2 00 	call	0x144	; 0x144 <spi_transfer>
/* send multiple bytes over SPI */
void nrf24_transmitSync(uint8_t* dataout,uint8_t len)
{
    uint8_t i;
    
    for(i=0;i<len;i++)
 4a4:	1f 5f       	subi	r17, 0xFF	; 255
 4a6:	10 13       	cpse	r17, r16
 4a8:	f8 cf       	rjmp	.-16     	; 0x49a <nrf24_writeRegister+0x2e>
{
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(W_REGISTER | (REGISTER_MASK & reg));
    nrf24_transmitSync(value,len);
    nrf24_csn_digitalWrite(HIGH);
}
 4aa:	0f 90       	pop	r0
 4ac:	0f 90       	pop	r0
 4ae:	df 91       	pop	r29
 4b0:	cf 91       	pop	r28
 4b2:	1f 91       	pop	r17
 4b4:	0f 91       	pop	r16
 4b6:	ff 90       	pop	r15
 4b8:	ef 90       	pop	r14
 4ba:	0c 94 9d 00 	jmp	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>

000004be <nrf24_rx_address>:
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 4be:	28 98       	cbi	0x05, 0	; 5

/* Set the RX address */
void nrf24_rx_address(uint8_t * adr) 
{
    nrf24_ce_digitalWrite(LOW);
    nrf24_writeRegister(RX_ADDR_P1,adr,nrf24_ADDR_LEN);
 4c0:	45 e0       	ldi	r20, 0x05	; 5
 4c2:	bc 01       	movw	r22, r24
 4c4:	8b e0       	ldi	r24, 0x0B	; 11
 4c6:	0e 94 36 02 	call	0x46c	; 0x46c <nrf24_writeRegister>
 4ca:	0c 94 9b 00 	jmp	0x136	; 0x136 <nrf24_ce_digitalWrite.part.0>

000004ce <nrf24_tx_address>:
    return payload_len;
}

/* Set the TX address */
void nrf24_tx_address(uint8_t* adr)
{
 4ce:	cf 93       	push	r28
 4d0:	df 93       	push	r29
 4d2:	ec 01       	movw	r28, r24
    /* RX_ADDR_P0 must be set to the sending addr for auto ack to work. */
    nrf24_writeRegister(RX_ADDR_P0,adr,nrf24_ADDR_LEN);
 4d4:	45 e0       	ldi	r20, 0x05	; 5
 4d6:	bc 01       	movw	r22, r24
 4d8:	8a e0       	ldi	r24, 0x0A	; 10
 4da:	0e 94 36 02 	call	0x46c	; 0x46c <nrf24_writeRegister>
    nrf24_writeRegister(TX_ADDR,adr,nrf24_ADDR_LEN);
 4de:	45 e0       	ldi	r20, 0x05	; 5
 4e0:	be 01       	movw	r22, r28
 4e2:	80 e1       	ldi	r24, 0x10	; 16
}
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
/* Set the TX address */
void nrf24_tx_address(uint8_t* adr)
{
    /* RX_ADDR_P0 must be set to the sending addr for auto ack to work. */
    nrf24_writeRegister(RX_ADDR_P0,adr,nrf24_ADDR_LEN);
    nrf24_writeRegister(TX_ADDR,adr,nrf24_ADDR_LEN);
 4e8:	0c 94 36 02 	jmp	0x46c	; 0x46c <nrf24_writeRegister>

000004ec <nrf24_setupPins>:
 *    - Set CSN pin output
 *    - Set CE pin output     */

void nrf24_setupPins()
{
    set_bit(DDRB,0); // CE output
 4ec:	20 9a       	sbi	0x04, 0	; 4
    set_bit(DDRB,4); // CSN output
 4ee:	24 9a       	sbi	0x04, 4	; 4
    set_bit(DDRB,7); // SCK output
 4f0:	27 9a       	sbi	0x04, 7	; 4
    set_bit(DDRB,5); // MOSI output
 4f2:	25 9a       	sbi	0x04, 5	; 4
    clr_bit(DDRB,6); // MISO input
 4f4:	26 98       	cbi	0x04, 6	; 4
 4f6:	08 95       	ret

000004f8 <nrf24_init>:
uint8_t payload_len;

/* init the hardware pins */
void nrf24_init() 
{
    nrf24_setupPins();
 4f8:	0e 94 76 02 	call	0x4ec	; 0x4ec <nrf24_setupPins>
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 4fc:	28 98       	cbi	0x05, 0	; 5
 4fe:	0c 94 9d 00 	jmp	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>

00000502 <nrf24_ce_digitalWrite>:
/* nrf24 CE pin control function
 *    - state:1 => Pin HIGH
 *    - state:0 => Pin LOW     */
void nrf24_ce_digitalWrite(uint8_t state)
{
    if(state)
 502:	81 11       	cpse	r24, r1
 504:	02 c0       	rjmp	.+4      	; 0x50a <nrf24_ce_digitalWrite+0x8>
    {
        set_bit(PORTB,0);
    }
    else
    {
        clr_bit(PORTB,0);
 506:	28 98       	cbi	0x05, 0	; 5
 508:	08 95       	ret
 50a:	0c 94 9b 00 	jmp	0x136	; 0x136 <nrf24_ce_digitalWrite.part.0>

0000050e <nrf24_csn_digitalWrite>:
    }
}
void nrf24_csn_digitalWrite(uint8_t state)
{
    if(state)
 50e:	81 11       	cpse	r24, r1
 510:	02 c0       	rjmp	.+4      	; 0x516 <nrf24_csn_digitalWrite+0x8>
    {
        set_bit(PORTB,4);
    }
    else
    {
        clr_bit(PORTB,4);
 512:	2c 98       	cbi	0x05, 4	; 5
 514:	08 95       	ret
 516:	0c 94 9d 00 	jmp	0x13a	; 0x13a <nrf24_csn_digitalWrite.part.1>

0000051a <nrf24_sck_digitalWrite>:
    }
}
void nrf24_sck_digitalWrite(uint8_t state)
{
    if(state)
 51a:	81 11       	cpse	r24, r1
 51c:	02 c0       	rjmp	.+4      	; 0x522 <nrf24_sck_digitalWrite+0x8>
    {
        set_bit(PORTB,7);
    }
    else
    {
        clr_bit(PORTB,7);
 51e:	2f 98       	cbi	0x05, 7	; 5
 520:	08 95       	ret
}
void nrf24_sck_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,7);
 522:	2f 9a       	sbi	0x05, 7	; 5
 524:	08 95       	ret

00000526 <nrf24_mosi_digitalWrite>:
        clr_bit(PORTB,7);
    }
}
void nrf24_mosi_digitalWrite(uint8_t state)
{
    if(state)
 526:	81 11       	cpse	r24, r1
 528:	02 c0       	rjmp	.+4      	; 0x52e <nrf24_mosi_digitalWrite+0x8>
    {
        set_bit(PORTB,5);
    }
    else
    {
        clr_bit(PORTB,5);
 52a:	2d 98       	cbi	0x05, 5	; 5
 52c:	08 95       	ret
}
void nrf24_mosi_digitalWrite(uint8_t state)
{
    if(state)
    {
        set_bit(PORTB,5);
 52e:	2d 9a       	sbi	0x05, 5	; 5
 530:	08 95       	ret

00000532 <nrf24_miso_digitalRead>:
 532:	83 b1       	in	r24, 0x03	; 3
 534:	80 74       	andi	r24, 0x40	; 64
 536:	08 95       	ret

00000538 <main>:
//slow down clock for low-voltage performance 
#define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))
#define CPU_8MHz        0x01

int main(void){
 CPU_PRESCALE(CPU_8MHz);
 538:	80 e8       	ldi	r24, 0x80	; 128
 53a:	80 93 61 00 	sts	0x0061, r24
 53e:	81 e0       	ldi	r24, 0x01	; 1
 540:	80 93 61 00 	sts	0x0061, r24

    /* init hardware pins */
    nrf24_init();
 544:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <nrf24_init>
    
    /* Channel #21 , payload length: 4 */
    nrf24_config(21,4);
 548:	64 e0       	ldi	r22, 0x04	; 4
 54a:	85 e1       	ldi	r24, 0x15	; 21
 54c:	0e 94 61 01 	call	0x2c2	; 0x2c2 <nrf24_config>
 
    /* Set the device addresses */
    nrf24_tx_address(tx_address);
 550:	85 e0       	ldi	r24, 0x05	; 5
 552:	91 e0       	ldi	r25, 0x01	; 1
 554:	0e 94 67 02 	call	0x4ce	; 0x4ce <nrf24_tx_address>
    nrf24_rx_address(rx_address);
 558:	80 e0       	ldi	r24, 0x00	; 0
 55a:	91 e0       	ldi	r25, 0x01	; 1
 55c:	0e 94 5f 02 	call	0x4be	; 0x4be <nrf24_rx_address>

    while(1)
    {    
        if(nrf24_dataReady())
 560:	0e 94 08 02 	call	0x410	; 0x410 <nrf24_dataReady>
 564:	88 23       	and	r24, r24
 566:	e1 f3       	breq	.-8      	; 0x560 <main+0x28>
        {
            nrf24_getData(data_array);
 568:	8c e0       	ldi	r24, 0x0C	; 12
 56a:	91 e0       	ldi	r25, 0x01	; 1
 56c:	0e 94 3b 01 	call	0x276	; 0x276 <nrf24_getData>
            if(data_array[2] == 0x55){
 570:	80 91 0e 01 	lds	r24, 0x010E
 574:	85 35       	cpi	r24, 0x55	; 85
 576:	a1 f7       	brne	.-24     	; 0x560 <main+0x28>
              light_routine();
 578:	0e 94 75 00 	call	0xea	; 0xea <light_routine>
 57c:	f1 cf       	rjmp	.-30     	; 0x560 <main+0x28>

0000057e <_exit>:
 57e:	f8 94       	cli

00000580 <__stop_program>:
 580:	ff cf       	rjmp	.-2      	; 0x580 <__stop_program>
